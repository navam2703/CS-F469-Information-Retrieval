<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>PageRank API documentation</title>
<meta name="description" content="* Navam Shrivastav 2019A7PS0092H
* Sukrit Kumar 2019AAPS0231H
* Shrikrishna Lolla 2019AAPS0345H" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PageRank</code></h1>
</header>
<section id="section-intro">
<ul>
<li>Navam Shrivastav 2019A7PS0092H</li>
<li>Sukrit Kumar 2019AAPS0231H</li>
<li>Shrikrishna Lolla 2019AAPS0345H</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# coding: utf-8

&#39;&#39;&#39;
* Navam Shrivastav 2019A7PS0092H
* Sukrit Kumar 2019AAPS0231H
* Shrikrishna Lolla 2019AAPS0345H
&#39;&#39;&#39;
# In[7]:


import numpy as np
import pandas as pd 
import networkx as nx


# In[1]:


def getAdjacencyMatrix():
    &#34;&#34;&#34;
    Returns the adjacency matrix for a given user inputted graph
    with n nodes e edges each user defined
    &#34;&#34;&#34;
    n = int(input(&#34;Enter no of nodes in the graph &#34;))
    e = int(input(&#34;Enter no of edges in the graph&#34;))
    adj = np.zeros(shape=(n,n))
    for i in range(e):
        edge = input()
        i,j = edge.split(&#34;,&#34;)
        adj[int(i)-1,int(j)-1] = 1
    return adj


# In[2]:


# function to convert adjacency list to probability translation matrix
def convert_adj_to_prob(adj_matrix, teleport=0.0):
    &#34;&#34;&#34;
    Converts a given adjacency matrix to a probability translation matrix

    Inputs :

    Adjacency Matrix

    teleport probability (alpha)
    &#34;&#34;&#34;
    n = adj_matrix.shape[0]
    prob_matrix = np.zeros((n, n))
    row_sum = np.sum(adj_matrix, axis=1)
    teleport_prob = teleport / n
    for i in range(n):
        for j in range(n):
            if adj_matrix[i, j] == 1:
                prob_matrix[i, j] = ((1-teleport)*adj_matrix[i, j]) / (row_sum[i]) + teleport_prob
            else:
                prob_matrix[i, j] = teleport_prob
    return prob_matrix


# In[3]:


P = [[1/6,2/3,1/6],[5/12,1/6,5/12],[1/6,2/3,1/6]]


# In[4]:


P


# In[5]:


adj = [[0,1,0],[1,0,1],[0,1,0]]


# In[8]:


convert_adj_to_prob(np.array(adj),0.5)


# In[9]:


np.isclose(convert_adj_to_prob(np.array(adj),0.5),np.array(P))


# In[10]:


# Calculation of steady state left eigen vector using the numpy 
def getLeftEigenVector(P):
    &#34;&#34;&#34;
    Compute the left eigen vector for a given probability translation matrix using numpy
    &#34;&#34;&#34;
    values, Vector = np.linalg.eig(np.array(P).T)
    left_vec = Vector[:, np.argmax(values)].T
    left_vec_norm = (left_vec/left_vec.sum()).real
    return left_vec_norm

# In[11]:


# Run for a max no of iterations
def power_iteration_limit_iter(prob_matrix, max_iter=100):
    &#34;&#34;&#34;
    Compute and return the left eigen vector using the power iteration method
    
    Inputs : 
    
    prob_matrix

    max_iters : (optional) defaults to 100 iterations, compute the eigen vector for max_iter iterations
    &#34;&#34;&#34;
    n = prob_matrix.shape[0]
    eigen_vector = np.zeros(n)
    eigen_vector[0] = 1
    for i in range(max_iter):
        eigen_vector = prob_matrix.T.dot(eigen_vector)
    return eigen_vector


# In[100]:


# Or run until numpy considers them to be close enough
def power_iteration(prob_matrix):
    &#34;&#34;&#34;
    Compute the left eigen vector using the power iteration method, this method runs as long as the previous computed value is not close to the newest computed value
    this is checked using the np.isclose() command
    
    Inputs : 

    prob_matrix
    &#34;&#34;&#34;
    n = prob_matrix.shape[0]
    eigen_vector = np.zeros(n)
    eigen_vector[0] = 1
    eigen_vector_prev = eigen_vector
    while True:
        eigen_vector_prev = eigen_vector
        eigen_vector = prob_matrix.T.dot(eigen_vector)
        if np.isclose(eigen_vector,eigen_vector_prev).all():
            break;
    return eigen_vector


# In[12]:


getLeftEigenVector(np.array(P))


# In[13]:


#power_iteration(np.array(P))


# In[14]:


x1 = [5/18,4/9,5/18]
x1 # Answer according to the text book


# In[ ]:


ad = getAdjacencyMatrix()
pr = convert_adj_to_prob(ad,0.5)
power_iteration(pr)


# In[114]:


adj</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="PageRank.convert_adj_to_prob"><code class="name flex">
<span>def <span class="ident">convert_adj_to_prob</span></span>(<span>adj_matrix, teleport=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a given adjacency matrix to a probability translation matrix</p>
<p>Inputs :</p>
<p>Adjacency Matrix</p>
<p>teleport probability (alpha)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_adj_to_prob(adj_matrix, teleport=0.0):
    &#34;&#34;&#34;
    Converts a given adjacency matrix to a probability translation matrix

    Inputs :

    Adjacency Matrix

    teleport probability (alpha)
    &#34;&#34;&#34;
    n = adj_matrix.shape[0]
    prob_matrix = np.zeros((n, n))
    row_sum = np.sum(adj_matrix, axis=1)
    teleport_prob = teleport / n
    for i in range(n):
        for j in range(n):
            if adj_matrix[i, j] == 1:
                prob_matrix[i, j] = ((1-teleport)*adj_matrix[i, j]) / (row_sum[i]) + teleport_prob
            else:
                prob_matrix[i, j] = teleport_prob
    return prob_matrix</code></pre>
</details>
</dd>
<dt id="PageRank.getAdjacencyMatrix"><code class="name flex">
<span>def <span class="ident">getAdjacencyMatrix</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the adjacency matrix for a given user inputted graph
with n nodes e edges each user defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAdjacencyMatrix():
    &#34;&#34;&#34;
    Returns the adjacency matrix for a given user inputted graph
    with n nodes e edges each user defined
    &#34;&#34;&#34;
    n = int(input(&#34;Enter no of nodes in the graph &#34;))
    e = int(input(&#34;Enter no of edges in the graph&#34;))
    adj = np.zeros(shape=(n,n))
    for i in range(e):
        edge = input()
        i,j = edge.split(&#34;,&#34;)
        adj[int(i)-1,int(j)-1] = 1
    return adj</code></pre>
</details>
</dd>
<dt id="PageRank.getLeftEigenVector"><code class="name flex">
<span>def <span class="ident">getLeftEigenVector</span></span>(<span>P)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the left eigen vector for a given probability translation matrix using numpy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLeftEigenVector(P):
    &#34;&#34;&#34;
    Compute the left eigen vector for a given probability translation matrix using numpy
    &#34;&#34;&#34;
    values, Vector = np.linalg.eig(np.array(P).T)
    left_vec = Vector[:, np.argmax(values)].T
    left_vec_norm = (left_vec/left_vec.sum()).real
    return left_vec_norm</code></pre>
</details>
</dd>
<dt id="PageRank.power_iteration"><code class="name flex">
<span>def <span class="ident">power_iteration</span></span>(<span>prob_matrix)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the left eigen vector using the power iteration method, this method runs as long as the previous computed value is not close to the newest computed value
this is checked using the np.isclose() command</p>
<p>Inputs : </p>
<p>prob_matrix</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def power_iteration(prob_matrix):
    &#34;&#34;&#34;
    Compute the left eigen vector using the power iteration method, this method runs as long as the previous computed value is not close to the newest computed value
    this is checked using the np.isclose() command
    
    Inputs : 

    prob_matrix
    &#34;&#34;&#34;
    n = prob_matrix.shape[0]
    eigen_vector = np.zeros(n)
    eigen_vector[0] = 1
    eigen_vector_prev = eigen_vector
    while True:
        eigen_vector_prev = eigen_vector
        eigen_vector = prob_matrix.T.dot(eigen_vector)
        if np.isclose(eigen_vector,eigen_vector_prev).all():
            break;
    return eigen_vector</code></pre>
</details>
</dd>
<dt id="PageRank.power_iteration_limit_iter"><code class="name flex">
<span>def <span class="ident">power_iteration_limit_iter</span></span>(<span>prob_matrix, max_iter=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute and return the left eigen vector using the power iteration method</p>
<p>Inputs : </p>
<p>prob_matrix</p>
<p>max_iters : (optional) defaults to 100 iterations, compute the eigen vector for max_iter iterations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def power_iteration_limit_iter(prob_matrix, max_iter=100):
    &#34;&#34;&#34;
    Compute and return the left eigen vector using the power iteration method
    
    Inputs : 
    
    prob_matrix

    max_iters : (optional) defaults to 100 iterations, compute the eigen vector for max_iter iterations
    &#34;&#34;&#34;
    n = prob_matrix.shape[0]
    eigen_vector = np.zeros(n)
    eigen_vector[0] = 1
    for i in range(max_iter):
        eigen_vector = prob_matrix.T.dot(eigen_vector)
    return eigen_vector</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="PageRank.convert_adj_to_prob" href="#PageRank.convert_adj_to_prob">convert_adj_to_prob</a></code></li>
<li><code><a title="PageRank.getAdjacencyMatrix" href="#PageRank.getAdjacencyMatrix">getAdjacencyMatrix</a></code></li>
<li><code><a title="PageRank.getLeftEigenVector" href="#PageRank.getLeftEigenVector">getLeftEigenVector</a></code></li>
<li><code><a title="PageRank.power_iteration" href="#PageRank.power_iteration">power_iteration</a></code></li>
<li><code><a title="PageRank.power_iteration_limit_iter" href="#PageRank.power_iteration_limit_iter">power_iteration_limit_iter</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>